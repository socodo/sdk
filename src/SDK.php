<?php

namespace Socodo\SDK;

use ReflectionAttribute;
use ReflectionClass;
use ReflectionException;
use ReflectionProperty;
use Socodo\Http\Enums\HttpMethods;
use Socodo\Router\Interfaces\RouteCollectionInterface;
use Socodo\SDK\Attributes\ExcludeSDK;
use Socodo\SDK\Files\PackageJson;
use Socodo\SDK\Files\GitIgnore;
use Socodo\SDK\Files\TsConfigJson;
use Socodo\SDK\Files\TsInterface;
use Socodo\SDK\Files\TsNamespace;
use Throwable;

class SDK
{
    protected const STRUCTURE_SUPER_CLASS_NAME = 'Socodo\\Framework\\Spec\\Structure';

    /** @var string SDK name. */
    protected string $name;

    /** @var string SDK version. */
    protected string $version;

    /** @var string SDK description. */
    protected string $description = 'SDK generated by Socodo';

    /**
     * Constructor.
     *
     * @param string $name
     * @param string $version
     * @param string|null $description
     */
    public function __construct (string $name, string $version, ?string $description = null)
    {
        $this->setName($name);
        $this->setVersion($version);

        if ($description !== null)
        {
            $this->setDescription($description);
        }
    }

    /**
     * Get SDK name.
     *
     * @return string
     */
    public function getName (): string
    {
        return $this->name;
    }

    /**
     * Set SDK name.
     *
     * @param string $name
     * @return void
     */
    public function setName (string $name): void
    {
        $this->name = $name;
    }

    /**
     * Get SDK version.
     *
     * @return string
     */
    public function getVersion (): string
    {
        return $this->version;
    }

    /**
     * Set SDK version.
     *
     * @param string $version
     * @return void
     */
    public function setVersion (string $version): void
    {
        $this->version = $version;
    }

    /**
     * Get SDK description.
     *
     * @return string
     */
    public function getDescription (): string
    {
        return $this->description;
    }

    /**
     * Set SDK description.
     *
     * @param string $description
     * @return void
     */
    public function setDescription (string $description): void
    {
        $this->description = $description;
    }

    /**
     * Collect controllers and structures.
     *
     * @param RouteCollectionInterface $collection
     * @return array
     * @throws ReflectionException
     */
    public function collect (RouteCollectionInterface $collection): array
    {
        $routes = $collection->getRoutes();

        $controllers = [];
        $structures = [];
        foreach ($routes as $route)
        {
            $controller = $route->getController();
            if (is_string($controller))
            {
                if (str_contains($controller, '@'))
                {
                    $controller = explode('@', $controller, 2);
                }
                else
                {
                    $controller = [ $controller, '__invoke' ];
                }
            }

            if (!is_array($controller) || function_exists($controller[0]) || !class_exists($controller[0]) || !method_exists($controller[0], $controller[1]))
            {
                continue;
            }

            $class = new ReflectionClass($controller[0]);
            $excludeAttr = $class->getAttributes(ExcludeSDK::class, ReflectionAttribute::IS_INSTANCEOF);
            if (!empty($excludeAttr))
            {
                continue;
            }

            try
            {
                $method = $class->getMethod($controller[1]);
                $excludeAttr = $method->getAttributes(ExcludeSDK::class, ReflectionAttribute::IS_INSTANCEOF);
                if (!empty($excludeAttr))
                {
                    continue;
                }
            }
            catch (Throwable)
            {
                continue;
            }

            $return = $method->getReturnType()?->getName();
            if ($return === null)
            {
                $return = 'any';
            }
            elseif (is_subclass_of($return, self::STRUCTURE_SUPER_CLASS_NAME))
            {
                $structures = array_merge($structures, $this->collectStructure($return));
                $return = $structures[$return]->getName();
            }
            elseif (class_exists($return) || $return === 'object' || $return === 'array')
            {
                $return = 'any';
            }
            else
            {
                $return = 'string';
            }

            $compiled = $route->compile();

            $params = [];
            $rParams = $method->getParameters();
            foreach ($rParams as $rParam)
            {
                $name = $rParam->getName();
                if (!isset($compiled['params'][$name]))
                {
                    continue;
                }

                $type = $rParam->getType()?->getName();
                if ($type === null)
                {
                    $type = 'string';
                }
                elseif (isset($structures[$type]))
                {
                    $type = $structures[$type]->getName();
                }
                elseif (class_exists($type) || $type === 'object')
                {
                    $type = 'any';
                }
                elseif ($type === 'array')
                {
                    $type = 'Array<any>';
                }
                else
                {
                    $type = 'string';
                }

                $params[$name] = [
                    'type' => $type,
                    'regex' => $compiled['params'][$name],
                    'comment' => null
                ];
            }

            $path = array_reduce($compiled['segments'], static function (string $carry, array $segment) {
                if ($segment['type'] == 'literal')
                {
                    return $carry . '/' . $segment['name'];
                }
                return $carry . '/${' . $segment['name'] . '}';
            }, '');

            $comments = $this->parseDocComment($method->getDocComment());
            foreach ($comments['params'] as $name => $comment)
            {
                $params[$name]['comment'] = $comment;
            }
            $comment = $comments['description'];

            $controllers[] = [
                'class' => str_replace([ 'App\\Controllers\\', '\\' ], '', $controller[0]),
                'method' => $controller[1],
                'httpMethods' => $route->getMethods(),
                'path' => $path,
                'params' => $params,
                'return' => $return,
                'comment' => $comment,
            ];
        }

        $output = [
            'namespaces' => [],
            'interfaces' => $structures,
        ];

        foreach ($controllers as $controller)
        {
            if (!isset($output['namespaces'][$controller['class']]))
            {
                $ns = new TsNamespace($controller['class']);
                $ns->setFilePath('/src/Controllers/' . $controller['class'] . '.ts');
                $output['namespaces'][$controller['class']] = $ns;
            }

            /** @var TsNamespace $ns */
            $ns = $output['namespaces'][$controller['class']];

            /** @var HttpMethods $method */
            foreach ($controller['httpMethods'] as $method)
            {
                $name = $controller['method'];
                $method = $method->value;
                if (count($controller['httpMethods']) > 1)
                {
                    $name = strtolower($method) . ucfirst($name);
                }

                $ns->addMethod($name, $controller['params'], [
                    'path' => $controller['path'],
                    'method' => $method,
                    'return' => $controller['return'],
                ], $controller['comment']);
            }
        }

        return $output;
    }

    /**
     * Collect structures.
     *
     * @param string $structure
     * @return array
     * @throws ReflectionException
     */
    protected function collectStructure (string $structure): array
    {
        if (!is_subclass_of($structure, self::STRUCTURE_SUPER_CLASS_NAME))
        {
            return [];
        }

        $class = new ReflectionClass($structure);
        $excludeAttr = $class->getAttributes(ExcludeSDK::class, ReflectionAttribute::IS_INSTANCEOF);
        if (!empty($excludeAttr))
        {
            return [];
        }

        $i = new TsInterface('I' . str_replace([ 'App\\Structures\\', '\\' ], '', $structure));
        $i->setFilePath('/src/Structures/' . $i->getName() . '.ts');
        $output = [ $structure => $i ];

        $iProperties = [];
        $properties = $class->getProperties(ReflectionProperty::IS_PUBLIC);
        foreach ($properties as $property)
        {
            $comment = $this->parseDocComment($property->getDocComment());
            $iProperty = [
                'comment' => $comment['var'] ?? '',
                'name' => $property->getName(),
                'default' => $property->hasDefaultValue() ? $property->getDefaultValue() : null
            ];

            $type = $property->getType()?->getName();
            if ($type === null)
            {
                $iProperty['type'] = 'any';
            }
            elseif (is_subclass_of($type, self::STRUCTURE_SUPER_CLASS_NAME))
            {
                if (!isset($output[$type]))
                {
                    $output = array_merge($output, $this->collectStructure($type));
                }
                $iProperty['type'] = $output[$type]->getName();
            }
            elseif ($type === 'string')
            {
                $iProperty['type'] = 'string';
            }
            elseif ($type === 'int' || $type === 'double' || $type === 'float')
            {
                $iProperty['type'] = 'number';
                $iProperty['comment'] = ($iProperty['comment'] !== '' ? $iProperty['comment'] . "\n     * " : '') . 'Should be of type ' . $type . '.';
            }

            $iProperty['comment'] = '/**' . "\n     * " . $iProperty['comment'] . "\n     */";
            $iProperties[] = $iProperty;
        }

        $i->setProperties($iProperties);

        return $output;
    }

    /**
     * Parse DocBlock comment.
     *
     * @param string $comment
     * @return array
     */
    public function parseDocComment (string $comment): array
    {
        $comment = trim(substr($comment, 3, -2));
        $lines = explode("\n", $comment);
        $lines = array_map(static function (string $line) {
            return trim($line, ' *');
        }, $lines);

        $output = [
            'description' => null,
            'var' => null,
            'params' => [],
            'return' => null,
        ];

        $annotationStarted = false;
        $currentAnnotationType = null;
        $currentAnnotationId = null;
        foreach ($lines as $line)
        {
            if (str_starts_with($line, '@'))
            {
                $annotationStarted = true;
                $currentAnnotationType = substr(explode(' ', $line, 2)[0], 1);
                if ($currentAnnotationType === 'param')
                {
                    $currentAnnotationId = explode(' ', $line, 4);
                    $currentAnnotationId = substr($currentAnnotationId[2], 1);
                }
            }

            if (!$annotationStarted)
            {
                if ($output['description'] === null)
                {
                    $output['description'] = '';
                }

                $output['description'] .= $line . "\n";
                continue;
            }

            if ($currentAnnotationType == 'return')
            {
                if ($output['return'] === null)
                {
                    $line = explode(' ', $line, 3)[2] ?? '';
                    if ($line === '')
                    {
                        continue;
                    }

                    $output['return'] = '';
                }

                $line = trim($line);
                $output['return'] .= $line . "\n";
                continue;
            }

            if ($currentAnnotationType == 'var')
            {
                if ($output['var'] === null)
                {
                    $line = explode(' ', $line, 3)[2] ?? '';
                    if ($line === '')
                    {
                        continue;
                    }

                    $output['var'] = '';
                }

                $line = trim($line);
                $output['var'] .= $line . "\n";
                continue;
            }

            if ($currentAnnotationType == 'param')
            {
                if (!isset($output['params'][$currentAnnotationId]))
                {
                    $line = explode(' ', $line, 4)[3] ?? '';
                    if ($line === '')
                    {
                        continue;
                    }

                    $output['params'][$currentAnnotationId] = '';
                }

                $line = trim($line);
                $output['params'][$currentAnnotationId] .= $line . "\n";
            }
        }

        $output['description'] = $output['description'] === null ? null : trim($output['description']);
        $output['var'] = $output['var'] === null ? null : trim($output['var']);
        $output['return'] = $output['return'] === null ? null : trim($output['return']);
        $output['params'] = array_map(static function (string $param) {
            return trim($param);
        }, $output['params']);
        return $output;
    }

    /**
     * Compile to typescript project.
     *
     * @param string $dirPath
     * @param RouteCollectionInterface $collection
     * @return void
     * @throws ReflectionException
     */
    public function compile (string $dirPath, RouteCollectionInterface $collection): void
    {
        $writer = new Writer($dirPath);
        $writer->clearBasePath();

        $gitIgnore = $this->createGitIgnore();
        $writer->write($gitIgnore);

        $packageJson = $this->createPackageJson();
        $writer->write($packageJson);

        $tsConfigJson = $this->createTsConfigJson();
        $writer->write($tsConfigJson);

        $collected = $this->collect($collection);
        foreach ($collected['namespaces'] as $namespace)
        {
            $writer->write($namespace);
        }
        foreach ($collected['interfaces'] as $interface)
        {
            $writer->write($interface);
        }
    }

    /**
     * Create a new .gitignore
     *
     * @return GitIgnore
     */
    protected function createGitIgnore (): GitIgnore
    {
        $gitIgnore = new GitIgnore();

        $gitIgnore->addBlock('Logs', [
            'logs',
            '*.log',
            'npm-debug.log*',
            'yarn-debug.log*',
            'yarn-error.log*',
        ]);

        $gitIgnore->addBlock('Runtime data', [
            'pids',
            '*.pid',
            '*.seed',
            '*.pid.lock',
        ]);

        $gitIgnore->addBlock('Dependencies', [
            'node_modules/',
            'jspm_packages/',
            '.npm',
            '*.tgz',
            '.yarn-integrity',
        ]);

        $gitIgnore->addBlock('Builds', [
            'dist/',
            'dist_esm/',
            'build/Release',
            '.env',
        ]);

        return $gitIgnore;
    }

    /**
     * Create a new package.json
     *
     * @return PackageJson
     */
    protected function createPackageJson (): PackageJson
    {
        $packageJson = new PackageJson($this->getName(), $this->getVersion());
        $packageJson->setDescription($this->getDescription());

        $packageJson->setType('module');
        $packageJson->setMain('./dist/main.js');
        $packageJson->setExports([
            '.' => './dist/main.js',
            './*' => './dist/*/index.js',
        ]);

        $packageJson->setScripts([
            'build' => 'tsc',
        ]);

        $packageJson->setDependencies([
            'ky' => '^0.32.0',
            'ky-universal' => '^0.11.0',
            'module-alias' => '^2.2.2',
        ]);

        $packageJson->setDevDependencies([
            'ts-node' => '^10.9.1',
            'typescript' => '^4.9.3',
            '@types/node' => '^18.11.9',
        ]);

        return $packageJson;
    }

    /**
     * Create a new tsconfig.json.
     *
     * @return TsConfigJson
     */
    protected function createTsConfigJson (): TsConfigJson
    {
        $tsConfigJson = new TsConfigJson();
        $tsConfigJson->setData([
            'target' => 'ES2020',
            'lib' => [ 'ES2020' ],
            'module' => 'Node16',
            'moduleResolution' => 'Node16',
            'strict' => true,
            'esModuleInterop' => true,
            'skipLibCheck' => true,
            'forceConsistentCasingInFileNames' => true,
            'declaration' => true,
            'outDir' => './dist'
        ]);

        return $tsConfigJson;
    }
}